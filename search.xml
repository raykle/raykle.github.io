<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[使用 Moco 轻松搭建测试服务器]]></title>
      <url>http://raykle.coding.me/2016/09/03/%E4%BD%BF%E7%94%A8-Moco-%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>新公司的项目使用了 <a href="http://rap.taobao.org/" target="_blank" rel="external">RAP</a> 这一阿里推出的可视化接口管理工具，通过在上面定义接口，RAP 可以通过分析接口结构，以一系列自动化工具帮助开发人员提升效率。重要的是 RAP 通过 Mock 服务可以生成模拟数据。</p>
<p>以上的这些都不是讨论的重点，本篇文章主要是记录如何通过使用 Moco 搭建本地服务器，以达到在接口定义初期，就可以通过 Moco 调试接口，推进移动开发的进程。</p>
<h2 id="Moco-介绍"><a href="#Moco-介绍" class="headerlink" title="Moco 介绍"></a>Moco 介绍</h2><p>Moco 是一个基于 Java 开发的开源项目，在 GitHub 上有不少的关注：<a href="https://github.com/dreamhead/moco" target="_blank" rel="external">https://github.com/dreamhead/moco</a></p>
<blockquote>
<p>Moco is an easy setup stub framework.</p>
</blockquote>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><ol>
<li><p>下载编译好的 Jar 文件，目前版本是 0.11.0：<br><a href="https://repo1.maven.org/maven2/com/github/dreamhead/moco-runner/0.11.0/moco-runner-0.11.0-standalone.jar" target="_blank" rel="external">https://repo1.maven.org/maven2/com/github/dreamhead/moco-runner/0.11.0/moco-runner-0.11.0-standalone.jar</a></p>
<blockquote>
<p>需要注意的是，之后在运行此 Jar 文件时，需要预先安装好 Java 的 JDK。如果不知道有没有安装过，可在下载完上面的 Jar 文件后，双击打开，如果没有任何提示的话，说明已经安装过 JDK，否则会有一个提示去下载的弹出框。JDK 下载地址为：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a> ，选择适合自己电脑系统的版本进行下载安装。</p>
</blockquote>
</li>
<li><p>编写配置文件，像下面这个样子描述你的 Moco 服务的配置：</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"response"</span> : &#123;</span><br><span class="line">        <span class="attr">"text"</span> : <span class="string">"Hello World"</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p> 并命名为 foo.json 。</p>
</li>
<li><p>通过配置文件 foo.json 启动 Moco 服务<br> 在命令行输入：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar moco-runner-&lt;version&gt;-standalone.jar http -p 12306 -c foo.json</span><br></pre></td></tr></table></figure>
<p> 其中 <code>&lt;version&gt;</code> 替换为下载的 Jar 包的版本，此处为 <code>0.11.0</code> ，所以执行：<code>java -jar moco-runner-0.11.0-standalone.jar http -p 12306 -c foo.json</code> 。<br> -p 指定 Moco 服务端口。</p>
<blockquote>
<p>需要注意的是，执行以上的命令，需要先 cd 到 Jar 文件所在的目录，然后 foo.json 文件也需要放在同一个目录才行，否则会报错。或者可以通过使用 Jar 文件和 .json 文件绝对路径的方式也可以。<br>json 文件路径也可以使用相对路径，如：./json/foo.json</p>
</blockquote>
</li>
<li><p>访问 Web 服务<br> 浏览器访问：<code>http://localhost:12306</code> ，就可以看到令人惊喜的 “Hello World” 了。: )</p>
<hr>
</li>
</ol>
<h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>具体使用可参考 Moco 的 <a href="https://github.com/dreamhead/moco/blob/master/moco-doc/apis.md" target="_blank" rel="external">官方文档</a></p>
<h3 id="description-字段作为注释"><a href="#description-字段作为注释" class="headerlink" title="description 字段作为注释"></a>description 字段作为注释</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"any response"</span>,</span><br><span class="line">        <span class="attr">"response"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: <span class="string">"foo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在所有的 JSON APIs 中，使用 <code>description</code> 字段作为描述此配置的作用，在服务启动时此字段会被自动忽略掉。</p>
<hr>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"uri"</span> : <span class="string">"/foo"</span></span><br><span class="line">        &#125;,</span><br><span class="line">         <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"bar"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:12306/foo</code> ,就可以获取到内容：bar。</p>
<h4 id="Query-Parameter"><a href="#Query-Parameter" class="headerlink" title="Query Parameter"></a>Query Parameter</h4><p>带有参数的请求</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"uri"</span> : <span class="string">"/foo"</span>,</span><br><span class="line">          <span class="attr">"queries"</span> : &#123;</span><br><span class="line">              <span class="attr">"param"</span> : <span class="string">"blah"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"bar"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:12306/foo?param=blah</code> 获取到内容：bar。</p>
<h4 id="HTTP-Method"><a href="#HTTP-Method" class="headerlink" title="HTTP Method"></a>HTTP Method</h4><p>根据指定的 HTTP 方法返回 response ，也非常容易设置。<br>设置 GET 请求：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"request"</span> : &#123;</span><br><span class="line">         <span class="attr">"method"</span> : <span class="string">"get"</span>,</span><br><span class="line">         <span class="attr">"uri"</span> : <span class="string">"/foo"</span></span><br><span class="line">       &#125;,</span><br><span class="line">     <span class="attr">"response"</span> : &#123;</span><br><span class="line">         <span class="attr">"text"</span> : <span class="string">"bar"</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>GET 请求 <code>http://localhost:12306/foo</code> 获取到内容：bar。</p>
<p>设置其他请求同理。</p>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"method"</span> : <span class="string">"post"</span>,</span><br><span class="line">          <span class="attr">"headers"</span> : &#123;</span><br><span class="line">            <span class="attr">"content-type"</span> : <span class="string">"application/json"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"bar"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"uri"</span> : <span class="string">"/cookie"</span>,</span><br><span class="line">          <span class="attr">"cookies"</span> : &#123;</span><br><span class="line">              <span class="attr">"login"</span> : <span class="string">"true"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"success"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"method"</span> : <span class="string">"post"</span>,</span><br><span class="line">          <span class="attr">"forms"</span> : &#123;</span><br><span class="line">              <span class="attr">"name"</span> : <span class="string">"foo"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"bar"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>XML 格式目前也还在流行着，配置方法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span>: &#123;</span><br><span class="line">          <span class="attr">"uri"</span>: <span class="string">"/xml"</span>,</span><br><span class="line">          <span class="attr">"text"</span>: &#123;</span><br><span class="line">              <span class="attr">"xml"</span>: <span class="string">"&lt;request&gt;&lt;parameters&gt;&lt;id&gt;1&lt;/id&gt;&lt;/parameters&gt;&lt;/request&gt;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span>: &#123;</span><br><span class="line">          <span class="attr">"text"</span>: <span class="string">"foo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>如果 XML 文件很大的话，可以放在一个 xml 文件中，然后通过引用文件路径的方式来发起请求：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="attr">"request"</span>: &#123;</span><br><span class="line">            <span class="attr">"uri"</span>: <span class="string">"/xml"</span>,</span><br><span class="line">            <span class="attr">"file"</span>: &#123;</span><br><span class="line">                <span class="attr">"xml"</span>: <span class="string">"your_file.xml"</span></span><br><span class="line">              &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span>: &#123;</span><br><span class="line">          <span class="attr">"text"</span>: <span class="string">"foo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="JSON-Request"><a href="#JSON-Request" class="headerlink" title="JSON Request"></a>JSON Request</h4><h5 id="JSON-Text"><a href="#JSON-Text" class="headerlink" title="JSON Text"></a>JSON Text</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="attr">"request"</span>: &#123;</span><br><span class="line">            <span class="attr">"uri"</span>: <span class="string">"/json"</span>,</span><br><span class="line">            <span class="attr">"json"</span>: &#123;</span><br><span class="line">                <span class="attr">"foo"</span>: <span class="string">"bar"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"response"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: <span class="string">"foo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:12306/json</code> ，将 <code>{&quot;foo&quot;: &quot;bar&quot;}</code> 作为字符串 POST 到服务器。</p>
<h4 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h4><h5 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h5><p>你可能想通过正则表达式来匹配你的 request，<strong>match</strong> 可以帮到你<br>比如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span>: &#123;</span><br><span class="line">          <span class="attr">"uri"</span>: &#123;</span><br><span class="line">              <span class="attr">"match"</span>: <span class="string">"/\\w*/foo"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span>: &#123;</span><br><span class="line">          <span class="attr">"text"</span>: <span class="string">"bar"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>匹配任意类似 <code>http://localhost:12306/xxx/foo</code> 的请求，并返回：bar。其中的 <code>/\\w*</code> 表示以 <code>/</code> 开始，之后是任意数量的数字或字母。</p>
<h5 id="Starts-With-Ends-With-Contain"><a href="#Starts-With-Ends-With-Contain" class="headerlink" title="Starts With, Ends With, Contain"></a>Starts With, Ends With, Contain</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span>: &#123;</span><br><span class="line">          <span class="attr">"uri"</span>: &#123;</span><br><span class="line">              <span class="attr">"startsWith"</span>: <span class="string">"/foo"</span></span><br><span class="line">              //<span class="string">"endsWith"</span>: <span class="string">"foo"</span></span><br><span class="line">              //<span class="string">"contain"</span>: <span class="string">"foo"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span>: &#123;</span><br><span class="line">          <span class="attr">"text"</span>: <span class="string">"bar"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><h4 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h4><p>正如在之前的实例中看到的，直接返回一个文字内容非常简单：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"foo"</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"bar"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:12306/</code> 将 foo 作为字符串 POST 到服务端，则会直接返回内容：bar。<br>和 request 一样，如果 response 内容很多的话，可以放在一个文件中返回。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"foo"</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"file"</span> : <span class="string">"bar.response"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Status-Code"><a href="#Status-Code" class="headerlink" title="Status Code"></a>Status Code</h4><p>Moco 支持 HTTP 状态码的返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"foo"</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"status"</span> : <span class="number">200</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Header-1"><a href="#Header-1" class="headerlink" title="Header"></a>Header</h4><p>我们同样可以在 response 中指定 HTTP Header。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"foo"</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"headers"</span> : &#123;</span><br><span class="line">              <span class="attr">"content-type"</span> : <span class="string">"application/json"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><h5 id="Single-URL"><a href="#Single-URL" class="headerlink" title="Single URL"></a>Single URL</h5><p>我们可以像 proxy 一样，返回一个指定的 URL。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"foo"</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"proxy"</span> : <span class="string">"http://www.github.com"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>实际上，proxy 要更加的强大。它可以将所有的请求都指向指定的 url，包括 HTTP 的 method，version，header，content 等等。</p>
<h5 id="Failover"><a href="#Failover" class="headerlink" title="Failover"></a>Failover</h5><p>除了基础功能之外，proxy 也支持 failover，这意味着如果远程服务暂时不能起作用的话，moco 服务将知道从本地的配置中修复。<br>例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"foo"</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"proxy"</span> : &#123;</span><br><span class="line">              <span class="attr">"url"</span> : <span class="string">"http://localhost:12306/unknown"</span>,</span><br><span class="line">              <span class="attr">"failover"</span> : <span class="string">"failover.json"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Proxy 会将 request/response 成对地保存在你指定的 failover 文件中。如果 proxy 指定的目标不可用，proxy 将从这个文件中恢复。这个功能在开发环境下非常有用，尤其是当集成服务还没有稳定的时候。</p>
<h5 id="Playback"><a href="#Playback" class="headerlink" title="Playback"></a>Playback</h5><p>Moco 也支持 playback，支持将远程的 request 和 response 保存到本地文件中。failover 和 playback 的不同支持在于，playback 只会当本地的 request 和 response 不可用时才会进入远程服务。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"foo"</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"proxy"</span> : &#123;</span><br><span class="line">              <span class="attr">"url"</span> : <span class="string">"http://localhost:12306/unknown"</span>,</span><br><span class="line">              <span class="attr">"playback"</span> : <span class="string">"playback.json"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"uri"</span> : <span class="string">"/redirect"</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"redirectTo"</span> : <span class="string">"http://www.github.com"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie 同样可以放在 response 中。比如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"uri"</span> : <span class="string">"/cookie"</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"cookies"</span> : &#123;</span><br><span class="line">            <span class="attr">"login"</span> : <span class="string">"true"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>当访问 <code>http://localhost:12306/cookie</code> 时，在返回的 Header 中将会看到：<code>Set-Cookie : login=true; Path=/</code></p>
<h4 id="JSON-Response"><a href="#JSON-Response" class="headerlink" title="JSON Response"></a>JSON Response</h4><p>对于 JSON API， 直接返回一个 json object 就可以了。比如:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"request"</span>: &#123;</span><br><span class="line">            <span class="attr">"uri"</span>: <span class="string">"/json"</span></span><br><span class="line">          &#125;,</span><br><span class="line">        <span class="attr">"response"</span>: &#123;</span><br><span class="line">            <span class="attr">"json"</span>: &#123;</span><br><span class="line">                <span class="attr">"foo"</span> : <span class="string">"bar"</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:12306/json</code>，则会返回 json：<code>{&quot;foo&quot;:&quot;bar&quot;}</code></p>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>简单地启动 moco 服务时是通过命令来启动的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar moco-runner-&lt;version&gt;-standalone.jar http -p 12306 -c foo.json</span><br></pre></td></tr></table></figure>
<p>注意到这里有一个 <code>-c foo.json</code> ，此时只会将 <code>foo.json</code> 配置文件中的内容加载到服务中，如果仅仅通过以上的命令，则在调试多个接口时，需要不断的停止旧的服务、通过新的 json 配置文件启动新的服务，非常麻烦。</p>
<blockquote>
<p>Moco 支持动态加载配置文件，无论是修改还是添加配置文件都是不需要重启服务的。</p>
</blockquote>
<h4 id="配置文件的设置技巧"><a href="#配置文件的设置技巧" class="headerlink" title="配置文件的设置技巧"></a>配置文件的设置技巧</h4><p>配置文件的格式为一个 <strong>数组</strong> 类型的 JSON 格式，数组的每一个元素是一个 <code>request/response</code> 的配对。比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        // 此处配置了一个 request</span><br><span class="line">        "request" : &#123;</span><br><span class="line">          "uri" : "/foo"</span><br><span class="line">        &#125;,</span><br><span class="line">        // 此处配置了对应于上方 request 的 response</span><br><span class="line">        "response" : &#123;</span><br><span class="line">          "text" : "bar"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个 request/response 对，当中的 request 可以没有，则此时访问 <code>http://localhost:12306/</code> 时，Moco 就会直接将配置的 response 中的内容返回。</p>
</blockquote>
<p>上面说了配置文件内容是 <strong>数组</strong> 类型的，所以我们还可以这样写：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"uri"</span> : <span class="string">"/foo"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"bar"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"request"</span> : &#123;</span><br><span class="line">          <span class="attr">"uri"</span> : <span class="string">"/foo2"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"response"</span> : &#123;</span><br><span class="line">          <span class="attr">"text"</span> : <span class="string">"bar2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>此时我们加载了这个配置文件后，可以通过 <code>http://localhost:12306/foo</code> 和 <code>http://localhost:12306/foo2</code> 分别获取到 bar 和 bar2。这种对于需要测试的接口数量较少时，比较快速方便。</p>
<h4 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h4><p>Moco 支持在全局的配置文件中引入其他配置文件，这样就可以分服务定义配置文件，便于管理。<br>例如你有两个不同路径的 API：<code>http://xxx.com/path1/login</code> 和 <code>http://xxx.com/path2/pay</code> （登录和支付接口）。<br>按照上一小节（4.1.1）所讲，我们可以写好 login 和 pay 的两个配置文件（或写在一起），分别设置 request 的 url 为 <code>/path1/login</code> 和 <code>/path2/pay</code> 。如果需要测试的接口很多，则不利于管理，且 path1、path2 这么混乱的分布于不同的配置文件中，对于以后想要更改也很不方便。</p>
<p>正确的姿势应该是这样的：<br>同样写好 login.json 和 pay.json 两个配置文件，然后写一个 <strong>全局配置文件</strong> ，配置如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// config.json</span><br><span class="line">[</span><br><span class="line">	&#123;"context":"/path1", "include":"login.json"&#125;,</span><br><span class="line">	&#123;"context":"/path2", "include":"pay.json"&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>login 和 pay 两个文件没有特殊要求，和之前的写法一样。比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// register.json</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "request": &#123;</span><br><span class="line">            "uri": "/register",</span><br><span class="line">            "method": "POST",</span><br><span class="line">            "json": &#123;</span><br><span class="line">                "phone":"18688886666",</span><br><span class="line">                "password":"123456"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "response": &#123;</span><br><span class="line">            "json": &#123;</span><br><span class="line">                "state":"0"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// login.json</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "request": &#123;</span><br><span class="line">            "uri": "/login",</span><br><span class="line">            "method": "POST",</span><br><span class="line">            "json": &#123;</span><br><span class="line">                "amount":"100"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "response": &#123;</span><br><span class="line">            "json": &#123;</span><br><span class="line">                "state":"0"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后启动 Moco 服务的命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar moco-runner-&lt;version&gt;-standalone.jar http -p 12306 -g config.json</span><br></pre></td></tr></table></figure>
<p>要注意的是，最后指定的参数是 <strong><code>-g config.json</code></strong> !</p>
<p>如果只是想引入多个 json 文件的话，全局配置文件中可以不使用 <code>context</code> 字段。比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不使用 context 字段的 config.json。</span><br><span class="line">[</span><br><span class="line">    &#123;"include":"login.json"&#125;,</span><br><span class="line">    &#123;"include":"pay.json"&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<hr>
<p>（持续更新中…）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《iOS 与 OS X 多线程和内存管理》读书笔记之 GCD（二）]]></title>
      <url>http://raykle.coding.me/2016/08/16/%E3%80%8AiOS%20%E4%B8%8E%20OS%20X%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%20GCD%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="/2016/08/16/《iOS 与 OS X 多线程和内存管理》读书笔记之 GCD（一）/">第一篇基础篇 👈</a></p>
</blockquote>
<hr>
<h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h2><blockquote>
<p>作用：变更生成的 Dispatch Queue 的执行优先级。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="string">"com.iBinaryOrg.targetQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"queue1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">//设置优先级</span></span><br><span class="line">dispatch_set_target_queue(queue1, targetQueue);</span><br></pre></td></tr></table></figure>
<p>dispatch_set_target_queue 中第一个参数为指定要变更执行优先级的 Dispatch Queue，第二个参数为指定的与要使用的执行优先级相同优先级的 Dispatch Queue。</p>
<p>如上面代码中所示，将 Dispatch Queue 指定为 dispatch_set_target_queue 函数的参数，不仅可以变更 Dispatch Queue 的执行优先级，还可以作为 Dispatch Queue 的执行阶层。如果在多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某一个 Serial Dispatch Queue，那么原先本应该并行执行的多个 Serial Dispatch Queue，在目标 Serial Dispatch Queue 上只能同时执行一个处理。</p>
<blockquote>
<p>在必须将不可并行执行的处理追加到多个 Serial Dispatch Queue 中时，如果使用 dispatch_set_target_queue 函数将目标指定为某一个 Serial Dispatch Queue，即可防止处理并行执行。</p>
</blockquote>
<p>比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testTargetQueue &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="string">"com.iBinaryOrg.targetQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建 3 个同步队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"queue1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"queue2"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue3 = dispatch_queue_create(<span class="string">"queue3"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置优先级(标记 1)</span></span><br><span class="line">    dispatch_set_target_queue(queue1, targetQueue);</span><br><span class="line">    dispatch_set_target_queue(queue2, targetQueue);</span><br><span class="line">    dispatch_set_target_queue(queue3, targetQueue);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">dispatch_async</span>(targetQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"target queue in"</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">4</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"target queue out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1 in"</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1 out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2 in"</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2 out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue3, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3 in"</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3 out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2016-05-27 15:31:24.630 GCD_Demo[2540:25b] target queue in</span><br><span class="line">2016-05-27 15:31:28.634 GCD_Demo[2540:25b] target queue out</span><br><span class="line">2016-05-27 15:31:28.636 GCD_Demo[2540:25b] 1 in</span><br><span class="line">2016-05-27 15:31:31.640 GCD_Demo[2540:25b] 1 out</span><br><span class="line">2016-05-27 15:31:31.642 GCD_Demo[2540:25b] 2 in</span><br><span class="line">2016-05-27 15:31:33.645 GCD_Demo[2540:25b] 2 out</span><br><span class="line">2016-05-27 15:31:33.648 GCD_Demo[2540:25b] 3 in</span><br><span class="line">2016-05-27 15:31:34.651 GCD_Demo[2540:25b] 3 out</span><br></pre></td></tr></table></figure>
<p>以上的代码中，如果将（标记 1）处的 <code>dispatch_set_target_queue</code> 三句代码注释掉，则会出现以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2016-05-27 14:34:40.245 GCD_Demo[1796:1403] target queue in</span><br><span class="line">2016-05-27 14:34:40.246 GCD_Demo[1796:21b] 1 in</span><br><span class="line">2016-05-27 14:34:40.247 GCD_Demo[1796:4203] 2 in</span><br><span class="line">2016-05-27 14:34:40.247 GCD_Demo[1796:4303] 3 in</span><br><span class="line">2016-05-27 14:34:41.253 GCD_Demo[1796:4303] 3 out</span><br><span class="line">2016-05-27 14:34:42.253 GCD_Demo[1796:4203] 2 out</span><br><span class="line">2016-05-27 14:34:43.249 GCD_Demo[1796:21b] 1 out</span><br><span class="line">2016-05-27 14:34:44.249 GCD_Demo[1796:1403] target queue out</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正如在 <a href="/2016/08/16/《iOS 与 OS X 多线程和内存管理》读书笔记之 GCD（一）/#dispatch-queue-create">dispatch_queue_create</a> 小节中所说的，虽然 queue1、queue2 和 queue3 是串行队列，但由于将不同的 3 个 block 分别追加到了这 3 个串行队列中，所以这 3 个串行队列是<code>同时处理</code>的。</p>
</blockquote>
<hr>
<h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"waited at least three seconds."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：dispatch_after 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue。此源码与在 3 秒后用 dispatch_async 函数追加 Block 到 Main Dispatch Queue 的相同。</p>
</blockquote>
<p>第二个参数指定要追加处理的 Dispatch Queue，第三个参数指定记述要执行处理的 Block。</p>
<hr>
<h2 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDispatchGroup &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将队列添加进 group 中</span></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk0"</span>);&#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk1"</span>);&#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk2"</span>);&#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"done"</span>);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blk0</span><br><span class="line">blk2</span><br><span class="line">blk1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><code>dispatch_group_notify</code> ：用来监听队列中的任务已全部执行完毕，第三个参数 <code>block</code>用来执行 group 中任务完毕所响应的操作。</p>
<p>另外，在 Dispatch Group 中也可以使用 <code>dispatch_group_wait</code> 函数仅等待全部处理执行结束。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);<span class="comment">//第二个参数指定为等待的时间（超时），此处意味着永久等待。**只要属于 Dispatch Group 的处理尚未执行结束，就会一直等待，中途不能取消**</span></span><br></pre></td></tr></table></figure>
<p>如果想指定等待时间间隔为 1 秒时应做如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line"><span class="keyword">long</span> result = dispatch_group_wait(group, time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == result) &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  属于 Dispatch Group 的全部处理执行结束</span><br><span class="line">     */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  属于 Dispatch Group de 某一个处理还在执行中</span><br><span class="line">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当等待时间为 DISPATCH_TIME_FOREVER、由 dispatch_group_wait 函数返回时，由于属于 Dispatch Group 的处理必定全部执行结束，所以返回值恒定为 0.<br>这里的“等待”是什么意思呢？这意味着一旦调用 dispatch_group_wait 函数，该函数就处于调用的状态而不返回。即执行 dispatch_group_wait 函数的现在的线程（当前线程）停止。在经过 dispatch_group_wait 函数中指定的时间或属于指定 Dispatch Queue 的处理全部执行结束前，执行该函数的线程停止。</p>
</blockquote>
<p>指定 DISPATCH_TIME_NOW，则不用任何等待即可判定属于 Dispatch Group 的处理是否执行结束。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> result = dispatch_group_wait(group, DISPATCH_TIME_NOW);</span><br></pre></td></tr></table></figure>
<p>在主线程的 RunLoop 的每次循环中，可检查执行是否结束，从而不耗费多余的等待时间，虽然这样也可以，但一般在这种情况下，还是推荐用 <code>dispatch_group_notify</code> 函数追加结束处理到 Main Dispatch Queue 中。这是因为 <code>dispatch_group_notify</code> 函数可以简化源代码。</p>
<hr>
<h2 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h2><p>举例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDispatchBarrierAsync &#123;</span><br><span class="line">	<span class="comment">// 创建并行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.gcd.ForBarrier"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步执行并行队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blk0_for_reading"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blk1_for_reading"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blk2_for_reading"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blk3_for_reading"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 此处会等待已经追加到 concurrentQueue 中的 block 操作全部执行完成，</span></span><br><span class="line">    <span class="comment">// 再调用 dispatch_barrier_async 函数。</span></span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blk_for_writting"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 继续异步执行并行队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blk4_for_reading"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blk5_for_reading"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blk6_for_reading"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blk7_for_reading"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dispatch_barrier_async 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束之后，再将指定的处理追加到该 Concurrent Dispatch Queue 中。然后再由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复为一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2016-05-27 16:12:41.103 GCD_Demo[2540:4507] blk1_for_reading</span><br><span class="line">2016-05-27 16:12:41.102 GCD_Demo[2540:43d7] blk0_for_reading</span><br><span class="line">2016-05-27 16:12:41.105 GCD_Demo[2540:43d7] blk3_for_reading</span><br><span class="line">2016-05-27 16:12:41.106 GCD_Demo[2540:4507] blk2_for_reading</span><br><span class="line">2016-05-27 16:12:41.108 GCD_Demo[2540:43d7] blk_for_writting //&lt;--</span><br><span class="line">2016-05-27 16:12:41.109 GCD_Demo[2540:43d7] blk4_for_reading</span><br><span class="line">2016-05-27 16:12:41.112 GCD_Demo[2540:43d7] blk6_for_reading</span><br><span class="line">2016-05-27 16:12:41.109 GCD_Demo[2540:4507] blk5_for_reading</span><br><span class="line">2016-05-27 16:12:41.113 GCD_Demo[2540:43d7] blk7_for_reading</span><br></pre></td></tr></table></figure>
<p><em>使用 Concurrent Dispatch Queue 和 dispatch_barrier_async 函数可实现 高效率 的数据库访问和文件访问。</em></p>
<hr>
<h2 id="dispatch-sync-amp-死锁问题"><a href="#dispatch-sync-amp-死锁问题" class="headerlink" title="dispatch_sync &amp; 死锁问题"></a>dispatch_sync &amp; 死锁问题</h2><blockquote>
<p>既然有“async”，当然也有“sync”，即 <code>dispatch_sync</code> 函数。它意味着“同步”（synchonous），也就是将指定的 Block “同步”追加到制定的 Dispatch Queue 中。在追加 Block 执行结束之前，dispatch_sync 函数会一直等待。<br><strong>“等待” 意味着 <code>当前线程停止</code>。</strong></p>
</blockquote>
<p>一旦调用 dispatch_sync 函数，那么在制定的处理执行结束之前，该函数不会返回。</p>
<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="built_in">NSLog</span>@(<span class="string">@"Hello?"</span>);&#125;);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该源代码在 Main Dispatch Queue 即主线程中执行制定 Block，并等待其执行结束。而其实主线程正在执行 <code>这些源代码</code>，所以 <code>无法执行</code> 追加到 Main Dispatch Queue 中的 Block。下面的例子也一样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main();</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"Hello?"</span>);&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先异步地向串行队列（main queue）中追加一个 block1，在这个 block1 中又同步地向此串行队列（main queue）追加一个 block2。所以按照串行队列的工作原理，需要等 block1 执行完毕，才会执行 block2，而 block1 执行的内容，就是在同样的串行队列中同步执行 block2，block2 又需要等待 block1 执行完毕之后再执行。所以此处形成了一个互相等待的情况，造成<code>死锁</code>。<br>此处的 dispatch_async 函数会返回，而 dispatch_sync 永远不会返回。</p>
<p>Serial Dispatch Queue 也会引起相同的问题。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.gcd.serialDispatchQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"Hello?"</span>);&#125;);<span class="comment">// 无法输出 “Hello?”</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><p>dispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数按指定的次数将指定的 Block 追加到指定的 Dispatch Queue 中，并等待全部处理执行结束。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_apply(<span class="number">3</span>, queue, ^(size_t index) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zu"</span>, index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"done"</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 dispatch_apply 函数也与 dispatch_sync 函数相同，会等待处理执行结束，因此推荐在 <code>dispatch_async</code> 函数中 <strong>非同步</strong> 地执行 dispatch_apply 函数。</p>
</blockquote>
<hr>
<h2 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend / dispatch_resume"></a>dispatch_suspend / dispatch_resume</h2><p>挂起指定的 queue：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend(queue);</span><br></pre></td></tr></table></figure>
<p>恢复指定的 queue：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_resume(queue);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但尚未执行的处理在此之后停止执行。而恢复则使得这些处理能够继续执行。</p>
</blockquote>
<hr>
<h2 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h2><p>Dispatch Semaphore 是持有计数的信号，该计数是多线程编程中的计数类型信号。所谓信号，类似于过马路时常用的手旗。可以通过时举起手旗，不可通过时放下手旗。而在 Dispatch Semaphore 中，使用计数来实现该功能。计数为 0 时等待，计数为 1 或大于 1 时。减去 1 而不等待。</p>
<p>使用方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数表示计数的初始值。例子中将计数值初始化为 1。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p>dispatch_semaphore_wait 函数等待 Dispatch Semaphore 的计数值达到大于或等于 1.当计数值大于等于 1，或者在待机中计数值大于等于 1 时，对该计数进行减法并从 dispatch_semaphore_wait 函数返回。第二个函数指定等待时间。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line"><span class="keyword">long</span> result = dispatch_semaphore_wait(semaphore, time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == result) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * 由于 Dispatch Semaphore 的计数值达到大于等于 1</span><br><span class="line">     * 或者在待机中的指定时间内</span><br><span class="line">     * Dispatch Semaphore 的计数值达到大于等于 1</span><br><span class="line">     * 所以 Dispatch Semaphore 的计数值减去 1</span><br><span class="line">     *</span><br><span class="line">     * 可执行需要进行排他控制的锤炼</span><br><span class="line">     */</span></span><br><span class="line">     </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * 由于 Dispatch Semaphore 的计数值为 0</span><br><span class="line">     * 因此在达到指定时间为止待机</span><br><span class="line">     */</span></span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch_semaphore_wait 函数返回 0 时，可安全地执行需要进行排他控制的处理。<br>该处理结束时 <strong><code>通过 dispatch_semaphore_signal 函数将 Dispatch Semaphore 的计数值加 1</code></strong>.</p>
<p>Sample:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDispatchSemaphore &#123;</span><br><span class="line">	<span class="comment">//创建一个 semaphore</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    __block <span class="built_in">NSString</span> *strTest = <span class="string">@"test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.gcd.concurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//每次执行之前，先判定信号量是否大于 0，是的话就执行，否则等待。</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([strTest isEqualToString:<span class="string">@"test"</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"--%@--1--"</span>, strTest);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ([strTest isEqualToString:<span class="string">@"test"</span>]) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"--%@--2--"</span>, strTest);</span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];                </span><br><span class="line">            &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"==========changed========"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行完毕之后，信号量进行 +1 处理</span></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"--%@--3--"</span>, strTest);</span><br><span class="line">        </span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line"></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">        strTest = <span class="string">@"modify"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"--%@--4--"</span>, strTest);</span><br><span class="line"></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line"></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"--%@--5--"</span>, strTest);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2016-05-27 17:15:39.490 GCD_Demo[2540:4717] --test--1--</span><br><span class="line">2016-05-27 17:15:40.494 GCD_Demo[2540:4717] --test--2--</span><br><span class="line">2016-05-27 17:15:41.498 GCD_Demo[2540:4517] --test--3--</span><br><span class="line">2016-05-27 17:15:42.502 GCD_Demo[2540:442f] --modify--4--</span><br><span class="line">2016-05-27 17:15:43.505 GCD_Demo[2540:4283] --modify--5--</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解析：以上虽然 Block 都是在异步队列中执行，但是由于初始化 Semaphore 时是以 1 的信号量创建的，所以每一个 Block 在追加到异步队列中之后，由于执行之前都通过了信号量的判断，所以同时只有一个 Block 能够执行。直到一个 Block 执行完毕，恢复了信号量之后，下一个 Block 才能得以执行。</p>
</blockquote>
<hr>
<h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h2><p>dispatch_once 函数是保证在应用程序执行中只执行一次指定处理的API。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>单例模式</strong>，此源代码能够保证即使在多线程环境下执行，也是百分之百安全。</p>
</blockquote>
<hr>
<h2 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h2><p>（待完善）</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《iOS 与 OS X 多线程和内存管理》读书笔记之 GCD（一）]]></title>
      <url>http://raykle.coding.me/2016/08/16/%E3%80%8AiOS%20%E4%B8%8E%20OS%20X%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%20GCD%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>书籍链接：<a href="https://www.amazon.cn/Objective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-iOS%E4%B8%8EOS-X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9D%82%E6%9C%AC%E4%B8%80%E6%A0%91/dp/B00DE60G3S/ref=sr_1_1?ie=UTF8&amp;qid=1471501826&amp;sr=8-1&amp;keywords=iOS+%E4%B8%8E+OS+X+%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" target="_blank" rel="external">Objective-C 高级编程: iOS 与 OS X 多线程和内存管理</a></p>
</blockquote>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><p><code>异步</code>：提交任务之后立刻返回，在后台队列中执行任务。<br><code>同步</code>：提交的任务执行完之后，再返回。</p>
<p><code>并行执行</code>：提交到任务到队列中之后，比如按顺序提交了任务 1 和任务 2，在任务 1 开始执行之后，不管任务 1 有没有执行完毕，都开始执行任务 2。<br><code>串行执行</code>：提交到任务到队列中之后，比如按顺序提交了任务 1 和任务 2，只有在任务 1 执行完毕之后，才执行任务 2。</p>
<blockquote>
<p>异步 or 同步，由函数 <code>dispatch_sync（同步）</code> or <code>dispatch_async（异步）</code> 决定。<br>并行 or 串行，由队列本身决定。如添加任务到 <code>Serial Dispatch Queue（串行队列）</code> or <code>Concurrent Dispatch Queue（并行队列）</code> 队列中。</p>
</blockquote>
<hr>
<h2 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h2><blockquote>
<p>开发者要做的只是定义想执行的任务并追加到适当的 Dispatch Queue 中。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">//想要执行的任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>该源代码使用 Block 语法“定义想执行的任务”，通过 dispatch_async 函数“追加”赋值在变量 queue 的“Dispatch Queue 中”。仅这样就可使指定的 Block 在另一线程中执行。</p>
<p>“Dispatch Queue”是执行处理的等待队列。应用程序编写人员通过 dispatch_async 函数等 API，在 Block 语法中记述想执行的处理并将其追加到 Dispatch Queue 中。Dispatch Queue 按照追加的顺序（<strong><code>先进先出 FIFO</code></strong>）执行处理。</p>
<hr>
<h2 id="Dispatch-Queue-种类"><a href="#Dispatch-Queue-种类" class="headerlink" title="Dispatch Queue 种类"></a>Dispatch Queue 种类</h2><p><code>Serial Dispatch Queue</code> 等待现在执行中处理结果，使用一个线程。<br><code>Concurrent Dispatch Queue</code> 不等待现在执行中处理结果，使用多个线程</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 Serial Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"come.iBinaryOrg.serial"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block 0"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block 1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block 2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block 3"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>当变量为 Serial Dispatch Queue 时，因为要等待现在执行中的处理结束，所以首先执行 blk0，blk0 执行结束后，接着执行 blk1，blk1 结束后再开始执行 blk2，如此重复。同时执行的处理数只能有 1 个。即执行该源码后，一定按照以下顺序进行处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">block 0</span><br><span class="line">block 1</span><br><span class="line">block 2</span><br><span class="line">block 3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>当变量 queue 为 Concurrent Dispatch Queue 时，因为不用等待现在执行中的处理结果结束，所以首先执行 blk0，不管 blk0 的执行是否结束，都开始执行后面的 blk1，不管 blk1 的执行是否结束，都开始执行后面的 blk2，如此重复循环。</p>
<p>这样虽然不用等待处理结果，可以并行执行多个处理，但并行执行的处理数量取决于<code>当前系统的状态</code>。即 iOS 和 OS X 基于 Dispatch Queue 中的处理数、CPU 核数以及 CPU 负荷等当前系统的状态来决定 Concurrent Dispatch Queue 中并行执行的处理数。所谓“并行执行”，就是使用多个线程同时执行多个处理。</p>
<hr>
<h2 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h2><p>关于 Serial Dispatch Queue 生成个数的注意事项：</p>
<ul>
<li>使用 dispatch_queue_create 函数可生成任意多个 Dispatch Queue，当生成多个 Serial Dispatch Queue 时，各个 Serial Dispatch Queue 将 <strong><em>并行执行</em></strong>。虽然在一个 Serial Dispatch Queue 中同时只能执行一个追加处理，但如果将处理分别追加到4个 Serial Dispatch Queue 中，各个 Serial Dispatch Queue 执行一个，即为 <strong><em>同时执行4个处理</em></strong>。</li>
<li>一旦生成 Serial Dispatch Queue 并追加处理，系统对于一个 Serial Dispatch Queue 就只生成并使用一个线程。如果生成 2000 个 Serial Dispatch Queue，那么就生成 2000 个线程。<em>过多使用多线程，就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能。</em></li>
</ul>
<p>使用方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Serial Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> mySerialDispatchQueue = dispatch_queue_create(<span class="string">"com.iBinaryOrg.gcd.MySerialDispatchQueue"</span>, <span class="literal">NULL</span><span class="comment">/* 等同于 DISPATCH_QUEUE_SERIAL，串行队列 */</span>)；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(mySerialDispatchQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Blk on mySerialDispatchQueue"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Concurrent Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> myConcurrentDispatchQueue = dispatch_queue_create(<span class="string">"com.iBinaryOrg.gcd.MyConcurrentDispatchQueue"</span>, DISPATCH_QUEUE_CONCURRENT)；<span class="comment">// 并行队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(myConcurrentDispatchQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Blk on myConcurrentDispatchQueue"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Main-Dispatch-Queue-Global-Dispatch-Queue"><a href="#Main-Dispatch-Queue-Global-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue / Global Dispatch Queue"></a>Main Dispatch Queue / Global Dispatch Queue</h2><blockquote>
<p>Main Dispatch Queue 是 Serial Dispatch Queue。<br>Global Dispatch Queue 是 Concurrent Dispatch Queue。  </p>
</blockquote>
<p><strong>系统提供的 Dispatch Queue 种类：</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Dispatch Queue 种类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main Dispatch Queue</td>
<td>Serial DIspatch Queue</td>
<td>主线程执行</td>
</tr>
<tr>
<td>Serial Dispatch Queue (Hign Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：高 (最高优先)</td>
</tr>
<tr>
<td>Serial Dispatch Queue (Default Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：默认</td>
</tr>
<tr>
<td>Serial Dispatch Queue (Low Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：低</td>
</tr>
<tr>
<td>Serial Dispatch Queue (Background Priority)</td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：后台</td>
</tr>
</tbody>
</table>
<p><strong>使用举例</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在默认优先级的 Global Dispatch Queue 中执行block</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     *可并行执行的处理</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     *在 Main Dispatch Queue 中执行 block</span><br><span class="line">     */</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue, ^&#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         *只能在主线程中执行的处理</span><br><span class="line">         */</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Test]]></title>
      <url>http://raykle.coding.me/2016/07/12/Test/</url>
      <content type="html"><![CDATA[<h1 id="This-is-title"><a href="#This-is-title" class="headerlink" title="This is title"></a>This is title</h1><p>Hello, this is a <code>test</code> post. </p>
<blockquote>
<p>Life is like a box of chocolates, you never know what you’re going to get.</p>
</blockquote>
<p><em>this is code block</em><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello Swift."</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://raykle.coding.me/2016/05/31/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
